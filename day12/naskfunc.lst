     1 00000000                                 ; naskfunc
     2 00000000                                 ; TAB=4
     3 00000000                                 
     4 00000000                                 [FORMAT "WCOFF"]        ; 制作目标文件的模式
     5 00000000                                 [INSTRSET "i486p"]      ; 告诉NASK。程序是给486使用的
     6 00000000                                 [BITS 32]               ; 制作32位模式用的机械语言
     7 00000000                                 
     8 00000000                                 ; 制作目标文件的信息
     9 00000000                                 [FILE "naskfunc.nas"]   ; 源文件名信息
    10 00000000                                 
    11 00000000                                 ; 程序中包含的函数名
    12 00000000                                 GLOBAL  _io_hlt, _io_cli, _io_sti, _io_stihlt
    13 00000000                                 GLOBAL  _io_in8,  _io_in16,  _io_in32
    14 00000000                                 GLOBAL  _io_out8, _io_out16, _io_out32
    15 00000000                                 GLOBAL  _io_load_eflags, _io_store_eflags
    16 00000000                                 GLOBAL _load_gdtr, _load_idtr
    17 00000000                                 GLOBAL	_asm_inthandler21, _asm_inthandler27, _asm_inthandler2c, _asm_inthandler20
    18 00000000                                 GLOBAL _load_cr0, _store_cr0
    19 00000000                                 GLOBAL _memtest_sub
    20 00000000                                 
    21 00000000                                 EXTERN	_inthandler20, _inthandler21, _inthandler27, _inthandler2c
    22 00000000                                 
    23 00000000                                 ; 以下是实际的函数代码
    24                                          [SECTION .text]         ; 目标文件中写了这些之后再写程序
    25 00000000                                 
    26 00000000                                 ; 待机
    27 00000000                                 ; void io_hlt(void);
    28 00000000                                 _io_hlt:
    29 00000000 F4                                      HLT
    30 00000001 C3                                      RET
    31 00000002                                 
    32 00000002                                 ; 将许可标志全部置为0，禁止所有中断
    33 00000002                                 ; void io_cli(void);
    34 00000002                                 _io_cli:
    35 00000002 FA                                      CLI
    36 00000003 C3                                      RET
    37 00000004                                 
    38 00000004                                 ; 将许可标志全部置为1，允许所有中断
    39 00000004                                 ; void io_sti(void);
    40 00000004                                 _io_sti:
    41 00000004 FB                                      STI
    42 00000005 C3                                      RET
    43 00000006                                 
    44 00000006                                 ; 允许所有中断，并待机
    45 00000006                                 ; void io_stihlt(void);
    46 00000006                                 _io_stihlt:
    47 00000006 FB                                      STI
    48 00000007 F4                                      HLT
    49 00000008 C3                                      RET
    50 00000009                                 
    51 00000009                                 ; 通过指定端口获取8位数据
    52 00000009                                 ; int io_in8(int port);
    53 00000009                                 _io_in8:
    54 00000009 8B 54 24 04                             MOV     EDX,[ESP+4]     ; port
    55 0000000D B8 00000000                             MOV     EAX,0
    56 00000012 EC                                      IN      AL,DX
    57 00000013 C3                                      RET
    58 00000014                                 
    59 00000014                                 ; 通过指定端口获取16位数据
    60 00000014                                 ; int io_in16(int port);
    61 00000014                                 _io_in16:
    62 00000014 8B 54 24 04                             MOV     EDX,[ESP+4]     ; port
    63 00000018 B8 00000000                             MOV     EAX,0
    64 0000001D 66 ED                                   IN      AX,DX
    65 0000001F C3                                      RET
    66 00000020                                 
    67 00000020                                 ; 通过指定端口获取32位数据
    68 00000020                                 ; int io_in32(int port);
    69 00000020                                 _io_in32:
    70 00000020 8B 54 24 04                             MOV     EDX,[ESP+4]     ; port
    71 00000024 B8 00000000                             MOV     EAX,0
    72 00000029 ED                                      IN      EAX,DX
    73 0000002A C3                                      RET
    74 0000002B                                 
    75 0000002B                                 ; 向指定端口发送8位数据
    76 0000002B                                 ; void io_out8(int port, int data);
    77 0000002B                                 _io_out8:   
    78 0000002B 8B 54 24 04                             MOV     EDX,[ESP+4]     ; port
    79 0000002F 8A 44 24 08                             MOV     AL,[ESP+8]      ; data
    80 00000033 EE                                      OUT     DX,AL
    81 00000034 C3                                      RET
    82 00000035                                         
    83 00000035                                 ; 向指定端口发送16位数据
    84 00000035                                 ; void io_out16(int port, int data);
    85 00000035                                 _io_out16:   
    86 00000035 8B 54 24 04                             MOV     EDX,[ESP+4]     ; port
    87 00000039 8A 44 24 08                             MOV     AL,[ESP+8]      ; data
    88 0000003D 66 EF                                   OUT     DX,AX
    89 0000003F C3                                      RET
    90 00000040                                         
    91 00000040                                 ; 向指定端口发送32位数据
    92 00000040                                 ; void io_out32(int port, int data);
    93 00000040                                 _io_out32:   
    94 00000040 8B 54 24 04                             MOV     EDX,[ESP+4]     ; port
    95 00000044 8A 44 24 08                             MOV     AL,[ESP+8]      ; data
    96 00000048 EF                                      OUT     DX,EAX
    97 00000049 C3                                      RET
    98 0000004A                                 
    99 0000004A                                 ; 获取EFLAGS寄存器
   100 0000004A                                 ; int io_load_eflags(void);
   101 0000004A                                 _io_load_eflags:
   102 0000004A 9C                                      PUSHFD      ; 指 PUSH EFLAGS
   103 0000004B 58                                      POP     EAX
   104 0000004C C3                                      RET
   105 0000004D                                 
   106 0000004D                                 ; 写入EFLAGS寄存器
   107 0000004D                                 ; void io_store_eflags(int eflags);
   108 0000004D                                 _io_store_eflags:
   109 0000004D 8B 44 24 04                     MOV     EAX,[ESP+4]
   110 00000051 50                              PUSH    EAX
   111 00000052 9D                              POPFD       ; 指 POP EFLAGS
   112 00000053 C3                              RET
   113 00000054                                 
   114 00000054                                 ; 内存写入1字节
   115 00000054                                 _write_mem8:    ; void write_mem8(int addr, int data);
   116 00000054                                         ;; ESP: 栈指针寄存器
   117 00000054 8B 4C 24 04                             MOV     ECX,[ESP+4]     ; [ESP + 4]中存放的是地址，将其读入ECX（扩展计数寄存器：32位）
   118 00000058 8A 44 24 08                             MOV     AL,[ESP+8]      ; [ESP + 8]中存放的是数据，将其读入AL 
   119 0000005C 88 01                                   MOV     [ECX],AL
   120 0000005E C3                                      RET
   121 0000005F                                 
   122 0000005F                                 ; 
   123 0000005F                                 ; void load_gdtr(int limit, int addr);
   124 0000005F                                 _load_gdtr:
   125 0000005F                                         ; 由于GDTR是48位寄存器，给它赋值的时候，唯一的方法就是指定一个内存地址，从指定的地址读取6个字节，再使用LGDT命令完成赋值
   126 0000005F                                         ; 假设limit为0xffff，addr是0x270000
   127 0000005F                                         ; ESP+4开始的内容应该是 [FF FF 00 00 / 00 00 27 00 ]（要注意低位放在内存地址小的字节里2）（使用/区分2个入参）
   128 0000005F                                         ; 使用AX取出0xffff [FF FF]
   129 0000005F 66 8B 44 24 04                          MOV     AX,[ESP+4]
   130 00000064                                         ; 从ESP+6偏移开始写入
   131 00000064 66 89 44 24 06                          MOV     [ESP+6],AX
   132 00000069                                         ; 此时的ESP变为 [FF FF FF FF / 00 00 27 00 ]
   133 00000069                                         ; 从ESP+6偏移开始读入6字节到GDTR寄存器
   134 00000069 0F 01 54 24 06                          LGDT    [ESP+6]
   135 0000006E C3                                      RET
   136 0000006F                                 
   137 0000006F                                 ; IDTR与GDTR结构体基本上是一样的，程序也非常相似。
   138 0000006F                                 ; void load_idtr(int limit, int addr);
   139 0000006F                                 _load_idtr:
   140 0000006F 66 8B 44 24 04                          MOV     AX,[ESP+4]
   141 00000074 66 89 44 24 06                          MOV     [ESP+6],AX
   142 00000079 0F 01 5C 24 06                          LIDT    [ESP+6]
   143 0000007E C3                                      RET
   144 0000007F                                 
   145 0000007F                                 _asm_inthandler20:
   146 0000007F 06                                      PUSH	ES
   147 00000080 1E                                      PUSH	DS
   148 00000081 60                                      PUSHAD
   149 00000082 89 E0                                   MOV		EAX,ESP
   150 00000084 50                                      PUSH	EAX
   151 00000085 66 8C D0                                MOV		AX,SS
   152 00000088 8E D8                                   MOV		DS,AX
   153 0000008A 8E C0                                   MOV		ES,AX
   154 0000008C E8 [00000000]                           CALL	_inthandler20
   155 00000091 58                                      POP		EAX
   156 00000092 61                                      POPAD
   157 00000093 1F                                      POP		DS
   158 00000094 07                                      POP		ES
   159 00000095 CF                                      IRETD
   160 00000096                                 
   161 00000096                                 _asm_inthandler21:
   162 00000096 06                                      PUSH	ES
   163 00000097 1E                                      PUSH	DS
   164 00000098 60                                      PUSHAD
   165 00000099 89 E0                                   MOV		EAX,ESP
   166 0000009B 50                                      PUSH	EAX
   167 0000009C 66 8C D0                                MOV		AX,SS
   168 0000009F 8E D8                                   MOV		DS,AX
   169 000000A1 8E C0                                   MOV		ES,AX
   170 000000A3 E8 [00000000]                           CALL	_inthandler21
   171 000000A8 58                                      POP		EAX
   172 000000A9 61                                      POPAD
   173 000000AA 1F                                      POP		DS
   174 000000AB 07                                      POP		ES
   175 000000AC CF                                      IRETD
   176 000000AD                                 
   177 000000AD                                 _asm_inthandler27:
   178 000000AD 06                                      PUSH	ES
   179 000000AE 1E                                      PUSH	DS
   180 000000AF 60                                      PUSHAD
   181 000000B0 89 E0                                   MOV		EAX,ESP
   182 000000B2 50                                      PUSH	EAX
   183 000000B3 66 8C D0                                MOV		AX,SS
   184 000000B6 8E D8                                   MOV		DS,AX
   185 000000B8 8E C0                                   MOV		ES,AX
   186 000000BA E8 [00000000]                           CALL	_inthandler27
   187 000000BF 58                                      POP		EAX
   188 000000C0 61                                      POPAD
   189 000000C1 1F                                      POP		DS
   190 000000C2 07                                      POP		ES
   191 000000C3 CF                                      IRETD
   192 000000C4                                 
   193 000000C4                                 _asm_inthandler2c:
   194 000000C4 06                                      PUSH	ES
   195 000000C5 1E                                      PUSH	DS
   196 000000C6 60                                      PUSHAD
   197 000000C7 89 E0                                   MOV		EAX,ESP
   198 000000C9 50                                      PUSH	EAX
   199 000000CA 66 8C D0                                MOV		AX,SS
   200 000000CD 8E D8                                   MOV		DS,AX
   201 000000CF 8E C0                                   MOV		ES,AX
   202 000000D1 E8 [00000000]                           CALL	_inthandler2c
   203 000000D6 58                                      POP		EAX
   204 000000D7 61                                      POPAD
   205 000000D8 1F                                      POP		DS
   206 000000D9 07                                      POP		ES
   207 000000DA CF                                      IRETD
   208 000000DB                                 
   209 000000DB                                 ; 读取CR0寄存器
   210 000000DB                                 ; int load_cr0(void)
   211 000000DB                                 _load_cr0:
   212 000000DB 0F 20 C0                                MOV     EAX,CR0
   213 000000DE C3                                      RET
   214 000000DF                                 
   215 000000DF                                 ; 写入CR0寄存器
   216 000000DF                                 ; int store_cr0(int cr0)
   217 000000DF                                 _store_cr0:
   218 000000DF 8B 44 24 04                             MOV     EAX,[ESP+4]
   219 000000E3 0F 22 C0                                MOV     CR0,EAX
   220 000000E6                                 
   221 000000E6                                 ; 内存检查子函数，使用C编写会被编译器优化流程，故采用汇编完成
   222 000000E6                                 ; unsigned int memtest_sub(unsigned int start, unsigned int end)
   223 000000E6                                 _memtest_sub:
   224 000000E6 57                                      PUSH    EDI                     ;  （由于还要使用EBX, ESI, EDI）
   225 000000E7 56                                      PUSH    ESI
   226 000000E8 53                                      PUSH    EBX
   227 000000E9 BE AA55AA55                             MOV     ESI,0xaa55aa55          ; pat0 = 0xaa55aa55;
   228 000000EE BF 55AA55AA                             MOV     EDI,0x55aa55aa          ; pat1 = 0x55aa55aa;
   229 000000F3 8B 44 24 10                             MOV     EAX,[ESP+12+4]          ; i = start;
   230 000000F7                                 mts_loop:
   231 000000F7 89 C3                                   MOV     EBX,EAX
   232 000000F9 81 C3 00000FFC                          ADD     EBX,0xffc               ; p = i + 0xffc;
   233 000000FF 8B 13                                   MOV     EDX,[EBX]               ; old = *p;
   234 00000101 89 33                                   MOV     [EBX],ESI               ; *p = pat0;
   235 00000103 83 33 FF                                XOR     DWORD [EBX],0xffffffff  ; *p ^= 0xffffffff;
   236 00000106 3B 3B                                   CMP     EDI,[EBX]               ; if (*p != pat1) goto fin;
   237 00000108 75 18                                   JNE     mts_fin
   238 0000010A 83 33 FF                                XOR     DWORD [EBX],0xffffffff  ; *p ^= 0xffffffff;
   239 0000010D 3B 33                                   CMP     ESI,[EBX]               ; if (*p != pat0) goto fin;
   240 0000010F 75 11                                   JNE     mts_fin
   241 00000111 89 13                                   MOV     [EBX],EDX               ; *p = old;
   242 00000113 05 00001000                             ADD     EAX,0x1000              ; i += 0x1000;
   243 00000118 3B 44 24 14                             CMP     EAX,[ESP+12+8]          ; if (i <= end) goto mts_loop;
   244 0000011C                                 
   245 0000011C 76 D9                                   JBE     mts_loop
   246 0000011E 5B                                      POP     EBX
   247 0000011F 5E                                      POP     ESI
   248 00000120 5F                                      POP     EDI
   249 00000121 C3                                      RET
   250 00000122                                 mts_fin:
   251 00000122 89 13                                   MOV     [EBX],EDX               ; *p = old;
   252 00000124 5B                                      POP     EBX
   253 00000125 5E                                      POP     ESI
   254 00000126 5F                                      POP     EDI
   255 00000127 C3                                      RET